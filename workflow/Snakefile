from os.path import join, dirname


include: "rules/utils.smk"


containerized: config.get("container", "docker://logsdonlab/cdr-finder:latest")


# Workflow params
# Sample manifest dict.
MANIFEST = config["samples"]
OUTPUT_DIR = config.get("output_dir", "results")
LOG_DIR = config.get("log_dir", "logs")
BMK_DIR = config.get("benchmark_dir", "benchmarks")

# Thresholds and other params.
WINDOW = config["window_size"]
WINDOW_IDENT = config.get("window_size_ident", WINDOW)

CDR_THRESHOLD = config.get("cdr_threshold")
METHYL_SCORE_THRESHOLD = config.get("methyl_score_threshold")
DMETHYL_SCORE_THRESHOLD = config.get("dmethyl_score_threshold")
PLEN_SCORE_THRESHOLD = config.get("plen_score_threshold")
IDENT_THRESHOLD = config.get("ident_threshold", 95.0)

BP_MERGE = config.get("bp_merge")
BP_ALR_MERGE = config.get("bp_alr_merge", 8000)
RESTRICT_ALR = config.get("restrict_alr", True)


wildcard_constraints:
    sample="|".join(MANIFEST.keys()),


###
# Subset fasta: Extracts subsequence from target bed
###


rule subset_fasta:
    input:
        fasta=lambda wc: MANIFEST[wc.sample]["fasta"],
        bed=lambda wc: MANIFEST[wc.sample]["regions"],
    output:
        rm_fasta=join(OUTPUT_DIR, "fasta", "{sample}_subset.fasta"),
        rm_fasta_idx=join(OUTPUT_DIR, "fasta", "{sample}_subset.fasta.fai"),
    log:
        join(LOG_DIR, "subset_fasta_{sample}.log"),
    resources:
        mem=8,
        hrs=1,
    threads: 1
    conda:
        "envs/tools.yaml"
    shell:
        """
        bedtools getfasta -fi {input.fasta} -bed {input.bed} > {output.rm_fasta} 2> {log}
        samtools faidx {output.rm_fasta} 2>> {log}
        """


###
# Get methylation information.
###


rule get_methylation_bed:
    input:
        ref=lambda wc: MANIFEST[wc.sample]["fasta"],
        bam=lambda wc: MANIFEST[wc.sample]["bam"],
        region=lambda wc: MANIFEST[wc.sample]["regions"],
    output:
        methyl_bed=join(OUTPUT_DIR, "bed", "{sample}_methyl.bed"),
    log:
        join(LOG_DIR, "get_methylation_bed_{sample}.log"),
    benchmark:
        join(BMK_DIR, "get_methylation_bed_{sample}.tsv")
    params:
        preset="traditional",
        ref=lambda wc, input: f"<(zcat {input.ref})"
        if str(input.ref).endswith(".gz")
        else input.ref,
    threads: 4
    resources:
        mem=8,
        hrs=1,
    conda:
        "envs/tools.yaml"
    shell:
        """
        samtools index {input.bam} 2> {log}
        modkit pileup {input.bam} {output.methyl_bed} \
        --include-bed {input.region} \
        --threads {threads} \
        --ref {params.ref} \
        --preset {params.preset} 2>> {log}
        """


###
# Rename fasta to avoid RepeatMasker ID limit.
###
rule rename_fasta:
    input:
        fasta=rules.subset_fasta.output.rm_fasta,
        fasta_idx=rules.subset_fasta.output.rm_fasta_idx,
    output:
        renamed_fasta=temp(join(OUTPUT_DIR, "fasta", "{sample}_subset_renamed.fasta")),
        renamed_fasta_idx=temp(
            join(OUTPUT_DIR, "fasta", "{sample}_subset_renamed.fasta.fai")
        ),
        rename_key=join(OUTPUT_DIR, "fasta", "{sample}_subset_rename_key.tsv"),
    log:
        join(LOG_DIR, "rename_fasta_{sample}.log"),
    conda:
        "envs/tools.yaml"
    shell:
        """
        seqtk rename {input.fasta} "seq" > {output.renamed_fasta} 2> {log}
        samtools faidx {output.renamed_fasta} 2>> {log}
        paste -d'\\t' <(cut -f 1 {output.renamed_fasta_idx}) <(cut -f 1 {input.fasta_idx}) > {output.rename_key} 2>> {log}
        """


###
# run_rm: Runs repeatmasker on the extracted subsequence fasta from rule subset_fasta
###


rule run_rm:
    input:
        fasta=rules.rename_fasta.output.renamed_fasta,
    output:
        rm_out=join(
            OUTPUT_DIR,
            "rm",
            "{sample}_subset_renamed.fasta.out",
        ),
    log:
        join(LOG_DIR, "run_rm_{sample}.log"),
    benchmark:
        join(BMK_DIR, "run_rm_{sample}.tsv")
    params:
        engine="rmblast",
        species=config.get("species", "human"),
        output_dir=lambda wc, output: os.path.dirname(str(output)),
    resources:
        mem=8,
        hrs=12,
    threads: 12
    conda:
        "envs/tools.yaml"
    shell:
        """
        RepeatMasker \
        -engine {params.engine} \
        -species {params.species} \
        -dir {params.output_dir} \
        -qq \
        -pa {threads} \
        {input.fasta} > {log}
        """


###
# Calculates mean frequency in windows/bins of the methylation tsv over the target region
###


rule calc_windows:
    input:
        script=workflow.source_path("scripts/calculate_windows.py"),
        methylation_tsv=rules.get_methylation_bed.output,
        target_bed=lambda wc: MANIFEST[wc.sample]["regions"],
    output:
        binned_freq=join(OUTPUT_DIR, "bed", "{sample}_binned_freq.bed"),
    log:
        join(LOG_DIR, "calc_windows_{sample}.log"),
    benchmark:
        join(BMK_DIR, "calc_windows_{sample}.tsv")
    threads: 1
    resources:
        mem=8,
        hrs=1,
    threads: 1
    conda:
        "envs/python.yaml"
    params:
        window_size=WINDOW,
    shell:
        """
        python {input.script} \
        --target_bed {input.target_bed} \
        --methylation_tsv {input.methylation_tsv} \
        --window_size {params.window_size} \
        -p {threads} > {output} 2> {log}
        """


###
# Format RM: Converts Repeatmasker output to bedfile and extracts only ALR annotations
###


rule format_filter_RM:
    input:
        rm_out=rules.run_rm.output.rm_out,
        rename_key=rules.rename_fasta.output.rename_key,
    output:
        rm_bed=join(OUTPUT_DIR, "bed", "{sample}_rm.bed"),
        rm_alr_bed=join(OUTPUT_DIR, "bed", "{sample}_rm_ALR.bed"),
    log:
        join(LOG_DIR, "format_filter_RM_{sample}.log"),
    resources:
        mem=8,
        hrs=1,
    conda:
        "envs/tools.yaml"
    threads: 1
    shell:
        """
        awk -v OFS="\\t" '{{
            # Read key values in first file.
            if (FNR == NR) {{
                kv[$1]=$2;
                next;
            }}
            # Skip header.
            if (FNR > 5) {{
                # Replace renamed seq name with original.
                chr_name=kv[$5]
                # Get chr name without coordinates
                split(chr_name, chr_names, ":")
                print chr_names[1], $6, $7, $10, $11, $9 > "{output.rm_bed}"
                if ( $10 ~ "ALR" ) {{
                    print chr_names[1], $6, $7, $10, $9
                }}
            }}
        }}' {input.rename_key} {input.rm_out} > {output.rm_alr_bed} 2> {log}
        """


rule calculate_1D_identity:
    input:
        fasta=rules.subset_fasta.output.rm_fasta,
    output:
        bed_dir=directory(join(OUTPUT_DIR, "bed", "{sample}_seq_ident")),
    threads: 12
    log:
        join(LOG_DIR, "calculate_1D_identity_{sample}.log"),
    params:
        window_size=WINDOW_IDENT,
    conda:
        "envs/python.yaml"
    shell:
        """
        censtats self-ident \
        -i {input.fasta} \
        -o {output.bed_dir} \
        -x 1D \
        -w {params.window_size} \
        -p {threads} 2> {log}
        """


rule format_1d_ident:
    input:
        rules.calculate_1D_identity.output,
    output:
        bed_filtered=join(OUTPUT_DIR, "bed", "{sample}_filt_seq_ident.bed"),
        bed_all=join(OUTPUT_DIR, "bed", "{sample}_seq_ident.bed"),
    params:
        thr_ident=IDENT_THRESHOLD,
    log:
        join(LOG_DIR, "format_1d_ident_{sample}.log"),
    shell:
        """
        awk -v OFS="\\t" '{{
            match($1, "(.*?):", names);
            match($1, ":(.*?)-", sts);
            if ($4 > {params.thr_ident}) {{
                print names[1], $2 + sts[1], $3 + sts[1], $4 > "{output.bed_filtered}"
            }}
            print names[1], $2 + sts[1], $3 + sts[1], $4
        }}' {input}/*.bed > {output.bed_all} 2> {log}
        """


###
# Adjust coordinates by adding back target bed coords.
###
use rule add_target_bed_coords as add_target_bed_coords_rm_alr with:
    input:
        # 3-cols
        target_bed=lambda wc: MANIFEST[wc.sample]["regions"],
        # 5-cols
        bed=rules.format_filter_RM.output.rm_alr_bed,
    output:
        bed=join(OUTPUT_DIR, "bed", "{sample}_rm_ALR_adj.bed"),
    log:
        join(LOG_DIR, "add_target_bed_coords_rm_alr_{sample}.log"),
    params:
        col_st="$2",
        col_end="$3",
        col_add="$6",
        col_other=",$4,$5",


use rule add_target_bed_coords as add_target_bed_coords_rm with:
    input:
        target_bed=lambda wc: MANIFEST[wc.sample]["regions"],
        bed=rules.format_filter_RM.output.rm_bed,
    output:
        bed=join(OUTPUT_DIR, "bed", "{sample}_rm_adj.bed"),
    log:
        join(LOG_DIR, "add_target_bed_coords_rm_{sample}.log"),
    params:
        col_st="$2",
        col_end="$3",
        col_add="$7",
        col_other=",$4,$5,$6",


use rule add_target_bed_coords as add_target_bed_coords_windows with:
    input:
        target_bed=lambda wc: MANIFEST[wc.sample]["regions"],
        bed=rules.calc_windows.output,
    output:
        bed=join(OUTPUT_DIR, "bed", "{sample}_binned_freq_adj.bed"),
    log:
        join(LOG_DIR, "add_target_bed_coords_windows_{sample}.log"),
    params:
        col_st="$2",
        col_end="$3",
        col_add="$6",
        col_other=",$4,$5",


###
# Intersect RM: Merges repeatmasker bed file with desired bp slop
#               Intersects merged ALR bed file with binned methylation frequency bedfile and self sequence identity bedfile
###


rule intersect_RM:
    input:
        rm=(rules.add_target_bed_coords_rm_alr.output if RESTRICT_ALR else []),
        ident=(
            rules.format_1d_ident.output.bed_filtered
            if WINDOW_IDENT and IDENT_THRESHOLD
            else []
        ),
        binned_freq=rules.add_target_bed_coords_windows.output,
    output:
        intersect_bed=join(OUTPUT_DIR, "bed", "{sample}_intersect.bed"),
    log:
        join(LOG_DIR, "intersect_RM_{sample}.log"),
    benchmark:
        join(BMK_DIR, "intersect_RM_{sample}.tsv")
    resources:
        mem=8,
        hrs=1,
    params:
        bp_alr_merge=BP_ALR_MERGE,
        rm_cmd=lambda wc, input: bool(input.rm),
        ident_cmd=lambda wc, input: bool(input.ident),
    threads: 1
    conda:
        "envs/tools.yaml"
    shell:
        """
        if [ "{params.rm_cmd}" == "True" ] && [ "{params.ident_cmd}" == "True" ]; then
            {{ bedtools merge -i {input.rm} -d {params.bp_alr_merge} | \
            bedtools intersect -a {input.binned_freq} -b - | \
            bedtools intersect -a - -b {input.ident} ;}} > {output.intersect_bed} 2>> {log}
        elif [ "{params.rm_cmd}" == "True" ]; then
            {{ bedtools merge -i {input.rm} -d {params.bp_alr_merge} | \
            bedtools intersect -a {input.binned_freq} -b - ;}} > {output.intersect_bed} 2>> {log}
        elif [ "{params.ident_cmd}" == "True" ]; then
            bedtools intersect -a {input.binned_freq} -b {input.ident} > {output.intersect_bed} 2>> {log}
        else
            cp {input.binned_freq} {output.intersect_bed}
        fi
        """


checkpoint call_cdrs:
    input:
        script=workflow.source_path("scripts/cdr_finder.py"),
        methyl_bed=rules.intersect_RM.output.intersect_bed,
        override_chrom_params=lambda wc: (
            MANIFEST[wc.sample]["override_chrom_params"]
            if MANIFEST[wc.sample].get("override_chrom_params", [])
            else []
        ),
    output:
        cdrs=join(OUTPUT_DIR, "bed", "{sample}_CDR.bed"),
    log:
        join(LOG_DIR, "call_cdrs_{sample}.log"),
    benchmark:
        join(BMK_DIR, "call_cdrs_{sample}.tsv")
    resources:
        mem=8,
        hrs=1,
    params:
        bp_merge=f"--bp_merge {BP_MERGE}" if BP_MERGE else "",
        thr_cdr=f"--thr_cdr {CDR_THRESHOLD}" if CDR_THRESHOLD else "",
        thr_methyl_score=f"--thr_methyl_score {METHYL_SCORE_THRESHOLD}"
        if METHYL_SCORE_THRESHOLD
        else "",
        thr_dmethyl_score=f"--thr_dmethyl_score {DMETHYL_SCORE_THRESHOLD}"
        if DMETHYL_SCORE_THRESHOLD
        else "",
        thr_plen_score=f"--thr_plen_score {PLEN_SCORE_THRESHOLD}"
        if PLEN_SCORE_THRESHOLD
        else "",
        override_chrom_params=lambda wc, input: (
            f"--override_chrom_params {input.override_chrom_params}"
            if input.override_chrom_params
            else ""
        ),
    conda:
        "envs/python.yaml"
    threads: 1
    shell:
        """
        python {input.script} detect \
        -i {input.methyl_bed} \
        {params.bp_merge} \
        {params.thr_cdr} \
        {params.thr_dmethyl_score} \
        {params.thr_plen_score} \
        {params.thr_methyl_score} -p p_exp/{wildcards.sample} > {output} 2> {log}
        """


rule format_files_for_cenplot:
    input:
        script=workflow.source_path("scripts/format_files_for_cenplot.py"),
        plot_layout=workflow.source_path("scripts/plot_layout.toml"),
        binned_freq_bed=rules.add_target_bed_coords_windows.output,
        cdr_bed=rules.call_cdrs.output,
        rm_bed=rules.add_target_bed_coords_rm.output,
        ident_bed=rules.format_1d_ident.output.bed_all,
    output:
        cdr_bed=join(OUTPUT_DIR, "bed", "{sample}", "{ctg}", "cdr.bed"),
        cov_bed=join(OUTPUT_DIR, "bed", "{sample}", "{ctg}", "cov.bed"),
        methyl_cov_bed=join(OUTPUT_DIR, "bed", "{sample}", "{ctg}", "methyl_cov.bed"),
        methyl_avg_cov_bed=join(
            OUTPUT_DIR, "bed", "{sample}", "{ctg}", "methyl_avg_cov.bed"
        ),
        rm_bed=join(OUTPUT_DIR, "bed", "{sample}", "{ctg}", "rm.bed"),
        ident_bed=join(OUTPUT_DIR, "bed", "{sample}", "{ctg}", "ident.bed"),
        plot_layout=join(OUTPUT_DIR, "plot", "{sample}", "{ctg}_plot_layout.toml"),
    conda:
        "envs/python.yaml"
    params:
        outdir=lambda wc, output: dirname(dirname(output.cdr_bed)),
        esc_outdir=lambda wc, output: dirname(output.cdr_bed).replace("/", "\\/"),
    log:
        join(LOG_DIR, "format_files_for_cenplot_{sample}_{ctg}.log"),
    shell:
        """
        python {input.script} \
        --ctg {wildcards.ctg} \
        --bed_binned_freq {input.binned_freq_bed} \
        --bed_cdr {input.cdr_bed} \
        --bed_rm {input.rm_bed} \
        --bed_ident {input.ident_bed} \
        --outdir {params.outdir} 2> {log}
        # Replace outdir format string with outdir
        sed 's/{{outdir}}/{params.esc_outdir}/g' {input.plot_layout} > {output.plot_layout} 2> {log}
        """


rule plot_cdr:
    input:
        plot_layout=rules.format_files_for_cenplot.output.plot_layout,
    output:
        join(OUTPUT_DIR, "plot", "{sample}", "{ctg}.png"),
    log:
        join(LOG_DIR, "plot_cdr_{sample}_{ctg}.log"),
    benchmark:
        join(BMK_DIR, "plot_cdr_{sample}_{ctg}.tsv")
    params:
        outdir=lambda wc, output: dirname(output[0]),
    resources:
        mem=8,
        hrs=1,
    conda:
        "envs/python.yaml"
    shell:
        """
        cenplot draw -t {input.plot_layout} -c {wildcards.ctg} -d {params.outdir} -p 1 2> {log}
        """


def all_cdr_plots(wc):
    cdr_file = checkpoints.call_cdrs.get(**wc).output[0]
    ctgs = set()
    with open(cdr_file, "rt") as fh:
        for line in fh.readlines():
            ctg, *_ = line.strip().split("\t")
            ctgs.add(ctg)

    return expand(rules.plot_cdr.output, sample=wc.sample, ctg=ctgs)


rule cdr_plots:
    input:
        all_cdr_plots,
    output:
        touch(join(OUTPUT_DIR, "plot", "{sample}.done")),


rule all:
    input:
        expand(rules.call_cdrs.output, sample=MANIFEST.keys()),
        # expand(rules.cdr_plots.output, sample=MANIFEST.keys()),
    default_target: True
